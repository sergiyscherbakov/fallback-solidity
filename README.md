# Fallback Smart Contract

## Опис проєкту

Fallback - це навчальний смарт-контракт на мові Solidity, що демонструє роботу fallback-функцій, механізм зміни власника (ownership) та прийом Ether. Контракт показує, як можна стати власником через внески та використання функції receive().

### Основний функціонал:
- Відстеження внесків кожної адреси
- Можливість стати власником через великі внески
- Функція receive() для прийому Ether
- Виведення коштів (тільки для власника)
- Перегляд балансу контракту

## Розробник

**Сергій Щербаков**
- GitHub: [@sergiyscherbakov](https://github.com/sergiyscherbakov)
- Email: sergiyscherbakov@ukr.net

## Технічні деталі

- **Версія Solidity**: ^0.8.0
- **Ліцензія**: MIT
- **Тип**: Навчальний контракт (демонстрація вразливостей)

### Змінні стану:
- `contributions` - mapping що зберігає суму внесків кожної адреси
- `owner` - адреса поточного власника контракту

### Функції:

#### constructor()
При деплої встановлює відправника як власника і надає йому 1000 wei внесків.

#### contribute() payable
Приймає внески менше 0.001 ETH. Якщо загальна сума внесків перевищує внески власника, відправник стає новим власником.

#### getContribution() view
Повертає суму внесків поточного користувача.

#### withdraw() onlyOwner
Дозволяє власнику вивести весь баланс контракту.

#### receive() payable
Fallback-функція, яка автоматично робить відправника власником, якщо він вже робив внески раніше і надсилає будь-яку суму ETH.

#### getBalance() view
Повертає баланс контракту в wei.

## Інструкція з компіляції та деплою в Remix IDE

### Крок 1: Відкрити Remix IDE
1. Перейдіть на https://remix.ethereum.org/
2. Дочекайтесь повного завантаження інтерфейсу

### Крок 2: Створити новий файл
1. У лівій панелі натисніть на іконку "File Explorer"
2. Натисніть "Create New File"
3. Введіть ім'я файлу: `L1T1.sol`
4. Скопіюйте весь код з файлу `L1T1.sol` з цього репозиторію

### Крок 3: Компіляція контракту
1. Натисніть на іконку "Solidity Compiler" у лівій панелі
2. Виберіть версію компілятора `0.8.0` або вище
3. Натисніть кнопку **"Compile L1T1.sol"**
4. Перевірте, що компіляція успішна (зелена галочка)

### Крок 4: Деплой контракту
1. Натисніть на іконку "Deploy & Run Transactions"
2. У розділі **ENVIRONMENT** виберіть:
   - `Remix VM (Shanghai)` - для тестування
   - `Injected Provider - MetaMask` - для реальної мережі
3. У розділі **ACCOUNT** оберіть перший акаунт (це буде початковий власник)
4. У розділі **CONTRACT** оберіть `Fallback`
5. У полі **VALUE** встановіть `0 Wei` (конструктор не потребує коштів)
6. Натисніть **"Deploy"** (оранжева кнопка)
7. Контракт з'явиться у розділі **Deployed Contracts**

## Послідовність тестування контракту

### ВАЖЛИВО: Підготовка
- Для тестів потрібно використовувати різні акаунти (мінімум 2)
- Перший акаунт - це початковий власник
- Другий акаунт - буде користувачем/атакуючим

---

### Тест 1: Перевірка ініціалізації

**Мета**: Переконатися, що контракт правильно встановив власника

1. Натисніть кнопку **`owner`** (блакитна)
   - **Очікуваний результат**: Адреса першого акаунту (той, з якого деплоїли)
   - Наприклад: `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`

2. Розгорніть **`contributions`** (блакитна)
3. Вставте адресу власника з попереднього кроку
4. Натисніть **"call"**
   - **Очікуваний результат**: `1000` (1000 wei)

---

### Тест 2: Перевірка початкового балансу

**Мета**: Переконатися, що контракт порожній

1. Натисніть **`getBalance`**
   - **Очікуваний результат**: `0` (контракт не має коштів)

---

### Тест 3: Зробити внесок від власника

**Мета**: Перевірити функцію contribute()

**ВАЖЛИВО**: Переконайтесь, що вибрано перший акаунт (власник)

1. У полі **VALUE** вгорі введіть: `500` і оберіть `Wei`
2. Розгорніть функцію **`contribute`** (червона/оранжева)
3. Натисніть **"transact"**
4. Перевірте, що транзакція успішна

**Перевірка:**
1. Натисніть **`getBalance`**
   - **Очікуваний результат**: `500` wei

2. Натисніть **`getContribution`** (з першого акаунту)
   - **Очікуваний результат**: `0` (contribution не збільшився, бо власник вже мав 1000)

**ВИПРАВЛЕННЯ**: Насправді contributions має збільшитись до 1500 (1000 + 500)

---

### Тест 4: Зробити внесок від другого акаунту

**Мета**: Перевірити внески від іншого користувача

1. У розділі **ACCOUNT** переключіться на **другий акаунт**
   - Наприклад: `0xAb8483Fb90B4c8183A35F8e4b2c5c0E9e8F9fE8E`

2. У полі **VALUE** введіть: `800` Wei
3. Натисніть **`contribute`** → **"transact"**

**Перевірка:**
1. Натисніть **`getContribution`** (з другого акаунту)
   - **Очікуваний результат**: `800` wei

2. Натисніть **`getBalance`**
   - **Очікуваний результат**: `1300` wei (500 + 800)

3. Натисніть **`owner`**
   - **Очікуваний результат**: Все ще перший акаунт (власник не змінився, бо 800 < 1500)

---

### Тест 5: Обмеження на суму внеску

**Мета**: Перевірити require(msg.value < 0.001 ether)

1. Переконайтесь, що вибрано другий акаунт
2. У полі **VALUE** введіть: `1` і оберіть `Finney` (або `1000000000000000` Wei)
   - Це дорівнює 0.001 ETH
3. Натисніть **`contribute`** → **"transact"**

**Очікуваний результат:**
- Транзакція має **провалитись** (червоний хрестик)
- Помилка: транзакція відхилена через require

**Правильний тест:**
4. Змініть VALUE на `999` і оберіть `Szabo` (або `999000000000000` Wei)
   - Це менше 0.001 ETH
5. Натисніть **`contribute`** → **"transact"**
6. Транзакція має бути **успішною**

---

### Тест 6: Використання receive() для захоплення ownership

**Мета**: Стати власником через fallback функцію

**ВАЖЛИВО**: Другий акаунт вже має contributions > 0 з попередніх тестів

1. Переконайтесь, що вибрано **другий акаунт**
2. У полі **VALUE** введіть: `1` Wei
3. Розгорніть розділ **Low level interactions** (внизу контракту)
4. У полі біля кнопки **Transact** залиште порожнім (або введіть `0x`)
5. Натисніть червону кнопку **"Transact"**
   - Це надішле Ether на контракт без виклику функції, що активує receive()

**Перевірка:**
1. Натисніть **`owner`**
   - **Очікуваний результат**: Адреса другого акаунту!
   - Наприклад: `0xAb8483Fb90B4c8183A35F8e4b2c5c0E9e8F9fE8E`

2. Натисніть **`getBalance`**
   - **Очікуваний результат**: Баланс збільшився на 1 wei

**Вітаємо! Другий акаунт тепер є власником контракту!**

---

### Тест 7: Спроба використати receive() без попередніх внесків

**Мета**: Показати, що receive() не спрацює для нових адрес

1. Переключіться на **третій акаунт** (той, який не робив внесків)
   - Наприклад: `0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db`

2. У полі **VALUE** введіть: `1` Wei
3. У Low level interactions натисніть **"Transact"**

**Очікуваний результат:**
- Транзакція має **провалитись**
- Причина: `require(contributions[msg.sender] > 0)` не виконується

---

### Тест 8: Виведення коштів власником

**Мета**: Перевірити функцію withdraw()

1. Переключіться на **поточного власника** (другий акаунт після Тесту 6)
2. Запам'ятайте поточний баланс акаунту (показано у ACCOUNT вгорі)
3. Натисніть **`getBalance`** - запишіть баланс контракту
4. Натисніть **`withdraw`** (червона кнопка) → **"transact"**

**Перевірка:**
1. Натисніть **`getBalance`**
   - **Очікуваний результат**: `0` (всі кошти виведено)

2. Перевірте баланс власника у розділі ACCOUNT
   - **Очікуваний результат**: Баланс збільшився приблизно на суму, що була в контракті (мінус gas)

---

### Тест 9: Спроба виведення не-власником (негативний тест)

**Мета**: Перевірити модифікатор onlyOwner

1. Переключіться на акаунт, що **НЕ є власником** (перший або третій)
2. Спочатку зробіть невеликий внесок для поповнення контракту:
   - VALUE: `1000` Wei
   - Натисніть **`contribute`** → **"transact"**

3. Тепер спробуйте вивести кошти:
   - Натисніть **`withdraw`** → **"transact"**

**Очікуваний результат:**
- Транзакція має **провалитись**
- Помилка: `caller is not the owner`

---

### Тест 10: Перевірка contributions різних акаунтів

**Мета**: Підсумувати внески всіх учасників

1. Розгорніть **`contributions`**
2. Перевірте contribution для кожного акаунту:

**Перший акаунт** (початковий власник):
- Введіть адресу першого акаунту
- Натисніть **"call"**
- **Очікуваний результат**: `1500` або більше (залежно від тестів)

**Другий акаунт** (поточний власник):
- Введіть адресу другого акаунту
- Натисніть **"call"**
- **Очікуваний результат**: Сума всіх його внесків з Тестів 4, 5, 6

**Третій акаунт**:
- Введіть адресу третього акаунту
- Натисніть **"call"**
- **Очікуваний результат**: `0` (він не робив успішних внесків)

---

### Тест 11: Великий внесок для зміни власника через contribute()

**Мета**: Стати власником "легальним" шляхом

**Підготовка**: Дізнайтесь поточні contributions власника

1. Натисніть **`owner`** - отримайте адресу поточного власника
2. У **`contributions`** введіть цю адресу - отримайте суму (наприклад, 1800 wei)

**Тест**:
1. Переключіться на **третій акаунт**
2. Розрахуйте потрібну суму: contributions_власника + 1
   - Але пам'ятайте обмеження: кожен внесок < 0.001 ETH (1000000000000000 wei)
3. Зробіть кілька внесків по 900 Wei кожен, поки не перевищите contributions власника

Приклад:
- VALUE: `900` Wei → **`contribute`** → **"transact"**
- VALUE: `900` Wei → **`contribute`** → **"transact"**
- VALUE: `900` Wei → **`contribute`** → **"transact"** (загалом 2700 wei)

**Перевірка:**
1. Натисніть **`owner`**
   - **Очікуваний результат**: Адреса третього акаунту!

---

### Тест 12: Перевірка getContribution()

**Мета**: Переконатися, що функція повертає правильні дані

1. Переключайтесь між акаунтами та кожен раз натискайте **`getContribution`**
2. Порівняйте результати з даними з **`contributions`**
3. Вони мають співпадати

---

## Діаграма залежностей функцій

```
Деплой контракту (owner отримує 1000 wei contributions)
    ↓
Базові перевірки:
├── owner → перевірити поточного власника
├── getBalance → перевірити баланс контракту
└── getContribution → перевірити внески поточного користувача
    ↓
Внески через contribute():
├── Зробити внесок < 0.001 ETH
├── Перевірити оновлення contributions
└── Якщо contributions > owner.contributions → стати власником
    ↓
Використання receive():
├── Спочатку потрібно мати contributions > 0
├── Надіслати будь-яку суму ETH без виклику функції
└── Автоматично стати власником
    ↓
Виведення коштів:
└── withdraw() → тільки власник може вивести баланс
```

## Аналіз безпеки (для навчальних цілей)

### Вразливості:

1. **Легке захоплення ownership через receive()**
   - Атакуючому потрібно лише зробити мінімальний внесок через contribute()
   - Потім надіслати будь-яку суму прямо на контракт
   - Він одразу стає власником, навіть якщо його contributions << owner.contributions

2. **Відсутність захисту від front-running**
   - Власник може побачити транзакцію withdraw() від атакуючого
   - Але оскільки ownership змінюється легко, це менш критично

3. **Відсутність функції повернення ownership**
   - Якщо ownership втрачено, немає способу його повернути

4. **Integer precision**
   - Використання wei замість більших одиниць може призвести до помилок в розрахунках

### Як зробити контракт безпечнішим:

1. Видалити або захистити receive() функцію
2. Додати timelock для зміни ownership
3. Додати multisig для критичних операцій
4. Використовувати OpenZeppelin Ownable
5. Додати events для всіх змін ownership
6. Додати механізм emergency stop (circuit breaker)

## Можливі помилки та їх вирішення

### Помилка: "caller is not the owner"
**Причина**: Ви намагаєтесь викликати withdraw() не з акаунту власника
**Рішення**: Переключіться на акаунт поточного власника

### Помилка: "require assertion failed"
**Причина**: Не виконано умову в require (наприклад, msg.value >= 0.001 ETH)
**Рішення**: Перевірте параметри функції та умови

### Транзакція відхиляється при використанні receive()
**Причина**: Акаунт не має contributions > 0
**Рішення**: Спочатку зробіть внесок через contribute()

### Не можу знайти Low level interactions
**Причина**: Розділ може бути згорнутий
**Рішення**: Прокрутіть вниз у Deployed Contracts, розгорніть контракт повністю

## Висновки

Цей контракт демонструє:
- ✅ Роботу fallback/receive функцій
- ✅ Механізми контролю доступу (onlyOwner)
- ✅ Прийом та відправлення Ether
- ✅ Відстеження стану через mappings
- ⚠️ Вразливості у логіці зміни ownership

**Важливо**: Цей контракт створено для навчальних цілей. НЕ використовуйте його в production без серйозних доопрацювань безпеки!

## Ліцензія

MIT License - див. файл LICENSE

## Контакти

Якщо у вас виникли питання:
- Email: sergiyscherbakov@ukr.net
- GitHub: https://github.com/sergiyscherbakov/fallback-solidity

---

**Дата створення**: 27 жовтня 2025
**Версія**: 1.0.0
**Тип**: Навчальний контракт


## Автор

**Розробник:** Сергій Щербаков
**Email:** sergiyscherbakov@ukr.net
**Telegram:** @s_help_2010
